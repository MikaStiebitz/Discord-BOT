import re
import discord
import wavelink
from config import Auth
from discord.ext import commands
from wavelink.player import TrackEventPayload
from discord.ui import Select, View
import asyncio

class MusicButtonView(discord.ui.View):
    def __init__(self, vc):
        super().__init__()
        self.vc = vc
        self.is_playing = True


    @discord.ui.button(emoji="‚èÆÔ∏è", row=0, style=discord.ButtonStyle.gray)
    async def prev(self, interaction: discord.Interaction, button: discord.ui.Button):
        
        await interaction.response.defer()

    @discord.ui.button(emoji="‚èØÔ∏è", row=0, style=discord.ButtonStyle.gray)
    async def pause(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.is_playing:
            await self.vc.pause()
            self.is_playing = False
            await interaction.response.defer()
        else:
            await self.vc.resume()
            self.is_playing = True
            await interaction.response.defer()

    @discord.ui.button(emoji="‚è≠Ô∏è", row=0, style=discord.ButtonStyle.gray)
    async def skip(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.vc.queue.is_empty:
            print("empty")
            return 
        
        next_song = self.vc.queue.get()
        await self.vc.play(next_song)
        await interaction.response.defer()

    @discord.ui.button(emoji="üîá", row=1, style=discord.ButtonStyle.gray)
    async def mute(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.vc.set_volume(0)
        await interaction.response.defer()

    @discord.ui.button(emoji="üîâ", row=1, style=discord.ButtonStyle.gray)
    async def lower(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.vc.set_volume(self.vc.volume - 25)
        await interaction.response.defer()

    @discord.ui.button(emoji="üîä", row=1, style=discord.ButtonStyle.gray)
    async def higher(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.vc.set_volume(self.vc.volume + 25)
        await interaction.response.defer()

    @discord.ui.button(emoji="üîÄ", row=2, style=discord.ButtonStyle.gray)
    async def shuffle(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()

    @discord.ui.button(emoji="‚èπÔ∏è", row=2,
                       style=discord.ButtonStyle.gray)
    async def stopbtn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.vc.disconnect()
        await interaction.response.defer()

    @discord.ui.button(emoji="üîÅ", row=2, style=discord.ButtonStyle.gray)
    async def repeat(self, interaction: discord.Interaction, button: discord.ui.Button):
        #
        await interaction.response.defer()

class MusicCog(commands.Cog):
    
    def __init__(self, bot):
        self.bot = bot
        self.now_playing_message = None
        self.index = None
        self.history = list()
        self.seen_titles = set()
        self.unique_tracks = []
        self.wavelink_nodes = [
            wavelink.Node(uri=f"http://{Auth.LAVALINK_HOST}:{Auth.LAVALINK_PORT}", password=f"{Auth.LAVALINK_PASSWORD}")
        ]
        self.bot.loop.create_task(self.connect_nodes())
        self.queue = wavelink.Queue()

    async def connect_nodes(self):
        try:
            await self.bot.wait_until_ready()
            await wavelink.NodePool.connect(client=self.bot, nodes=self.wavelink_nodes)
        except Exception as e:
            print(e)

    @commands.Cog.listener()
    async def on_wavelink_track_end(self, payload: TrackEventPayload):
        try:
            if not payload.player.queue.is_empty:
                tracks = payload.player.queue.get()
                await payload.player.play(tracks)
                if self.now_playing_message:
                    await self.now_playing_message.delete()
                    message = await self.ctx.send(f"Now playing: {tracks.title} ({tracks.author})", view=MusicButtonView(payload.player))
                    self.now_playing_message = message
            else:
                await asyncio.sleep(10)
                if payload.player.queue.is_empty and not payload.player.is_playing():
                    await payload.player.disconnect()
                    if self.now_playing_message:
                        await self.now_playing_message.delete()
        except:
            pass
         

    @commands.hybrid_command()
    async def play(self, ctx: commands.Context, *, music: str):
        
        if not ctx.voice_client:
            vc: wavelink.Player = await ctx.author.voice.channel.connect(cls=wavelink.Player)
        else:
            vc: wavelink.Player = ctx.voice_client

        if re.match(r"^(http(s)?://)?((w){3}.)?youtu(be|.be)?(\.com)?/.+", music):
            track = await wavelink.YouTubeTrack.search(music, return_first=True)
        else:
            tracks = await wavelink.YouTubeTrack.search(music)
            if not tracks:
                await ctx.send("No search results found.")
                return
            
            self.unique_tracks.clear()
            for track in tracks:
                if track.title in self.seen_titles:
                    continue
                    
                self.unique_tracks.append(track)
                
                self.seen_titles.add(track.title)

            embed = discord.Embed(title="Search Results", color=discord.Color.blurple())
            for i, track in enumerate(self.unique_tracks[:5]):
                embed.add_field(name=f"{i+1}. {track.title}", value=track.author, inline=False)

            options = [discord.SelectOption(label=track.title) for track in self.unique_tracks[:5]]

            select = Select(
                placeholder="Choose a Song!",
                options=options
            )
            
            async def my_callback(interaction):
                self.index = select.values[0]
                await interaction.response.defer()
                event.set()

            viewSel = View()
            viewSel.add_item(select)

            select.callback = my_callback
            message = await ctx.send(embed=embed, view=viewSel)

            event = asyncio.Event()
            await event.wait()

            for i, item in enumerate(self.unique_tracks[:5]):
                if item.title == self.index:
                    track = self.unique_tracks[i]
                    await message.delete()
                break

        if vc.is_playing():
            self.history.append(track)
            print("queue")
            embed = discord.Embed(
                title=track.title,
                url=track.uri,
                color=discord.Color.blurple())
            embed.set_footer(
                text=f"Requested by {ctx.author}", icon_url=ctx.author.avatar.url)
            await ctx.reply(embed=embed)

            await vc.queue.put_wait(track)


        else:
            self.history.append(track)
            await vc.play(track)
            message = await ctx.send(f"Now playing: {track.title} ({track.author})", view=MusicButtonView(vc))
            self.now_playing_message = message

    @commands.hybrid_command()
    async def stop(self, ctx: commands.Context):
        if not ctx.voice_client:
            vc: wavelink.Player = await ctx.author.voice.channel.connect(cls=wavelink.Player)
        else:
            vc: wavelink.Player = ctx.voice_client
        await vc.disconnect()
        

    @commands.hybrid_command()
    async def skip(self, ctx):
        if not ctx.voice_client:
            vc: wavelink.Player = await ctx.author.voice.channel.connect(cls=wavelink.Player)
        else:
            vc: wavelink.Player = ctx.voice_client
        if vc.queue.is_empty:
            await ctx.reply("There are no more tracks!")
            return 
        self.current_track = vc.queue.get()
        await vc.play(self.current_track)

    @commands.hybrid_command()
    async def prev(self, ctx):
        
        if not ctx.voice_client:
            vc: wavelink.Player = await ctx.author.voice.channel.connect(cls=wavelink.Player)
        else:
            vc: wavelink.Player = ctx.voice_client
        if not self.history:
            await ctx.send("There are no previous songs.")
            return
        
        print(self.history)
        self.history.reverse()
        print(self.history)
        last_song = self.history.pop()
        
        await vc.play(last_song)
        
        await ctx.send(f"Now playing the previous song: {last_song}")
    

    @commands.command()
    async def pause(self, ctx):
        vc = ctx.voice_client
        if vc:
            if vc.is_playing() and not vc.is_paused():
                await vc.pause()
            else:
                await ctx.send("Nothing is playing.")
        else:
            await ctx.send("The bot is not connected to a voice channel")


    @commands.command()
    async def resume(self, ctx):
        vc = ctx.voice_client
        if vc:
            if vc.is_paused():
                await vc.resume()
            else:
                await ctx.send("Nothing is paused.")
        else:
            await ctx.send("The bot is not connected to a voice channel")
            
    

async def setup(client):
    await client.add_cog(MusicCog(client))